<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>16131zzzzzzzz</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2022-03-06T14:25:02.885Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>Haojia Zhu</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>hexo</title>
    <link href="http://example.com/2022/03/05/hexo/"/>
    <id>http://example.com/2022/03/05/hexo/</id>
    <published>2022-03-04T16:00:00.000Z</published>
    <updated>2022-03-06T14:25:02.885Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://pbs.twimg.com/media/EYyrqtIWoAAjgNv.jpg"></p><span id="more"></span>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://pbs.twimg.com/media/EYyrqtIWoAAjgNv.jpg&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    
    <category term="hexo" scheme="http://example.com/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>LaTeX</title>
    <link href="http://example.com/2022/02/27/Latex/"/>
    <id>http://example.com/2022/02/27/Latex/</id>
    <published>2022-02-26T16:00:00.000Z</published>
    <updated>2022-03-06T14:27:02.144Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://gitee.com/zhuhaojia2001/pic_go_pics/raw/master/img/latex_comic.jpg">)</p><span id="more"></span><h1 id="LaTeX"><a href="#LaTeX" class="headerlink" title="LaTeX"></a>LaTeX</h1><h2 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h2><p><a href="https://www.latexlive.com/">在线LaTeX公式编辑器-编辑器 (latexlive.com)</a></p><p><a href="https://mathpix.com/">Mathpix Snip</a></p><h2 id="速查表"><a href="#速查表" class="headerlink" title="速查表"></a>速查表</h2><p><img src="https://img-blog.csdnimg.cn/20191030230804862.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NzI3NjI2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/20191030230752154.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NzI3NjI2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><img src="https://gitee.com/zhuhaojia2001/pic_go_pics/raw/master/img/9368615-2051eb8ef8627902.png" alt="img"></p><h2 id="公式大全"><a href="#公式大全" class="headerlink" title="公式大全"></a>公式大全</h2><p><img src="https://gitee.com/zhuhaojia2001/pic_go_pics/raw/master/img/20190916101433335.png" alt="img"></p><p><img src="https://gitee.com/zhuhaojia2001/pic_go_pics/raw/master/img/9368615-3d2020da2a5cfd58.png" alt="img"></p><p><img src="https://gitee.com/zhuhaojia2001/pic_go_pics/raw/master/img/9368615-7fcbdefb396ba056.png" alt="img"></p><p><img src="https://gitee.com/zhuhaojia2001/pic_go_pics/raw/master/img/9368615-2ac87b614fed0f3f.png" alt="img"></p><p><a href="https://www.jianshu.com/p/22117d964baf">LATEX 公式总结 - 简书 (jianshu.com)</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://gitee.com/zhuhaojia2001/pic_go_pics/raw/master/img/latex_comic.jpg&quot;&gt;)&lt;/p&gt;</summary>
    
    
    
    
    <category term="LaTeX" scheme="http://example.com/tags/LaTeX/"/>
    
  </entry>
  
  <entry>
    <title>struct</title>
    <link href="http://example.com/2022/02/26/struct/"/>
    <id>http://example.com/2022/02/26/struct/</id>
    <published>2022-02-25T16:00:00.000Z</published>
    <updated>2022-03-01T08:44:29.712Z</updated>
    
    <content type="html"><![CDATA[<p><img src=""></p><span id="more"></span><h1 id="struct"><a href="#struct" class="headerlink" title="struct"></a>struct</h1><p>c中的struct内不能有函数，不能继承，如果名字和函数名冲突可以正常调用。</p><p>c++中的struct中可以定义函数，可以使用访问修饰，可以直接不带struct关键词使用。</p><p>若结构体的名字与函数名相同，可以正常运行且正常的调用，但是定义结构体变量时候只能用带struct的。</p><p>比如继承：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Base</span> &#123;</span>         </span><br><span class="line">    <span class="keyword">int</span> v1;</span><br><span class="line"><span class="comment">//    private:   //error!</span></span><br><span class="line">        <span class="keyword">int</span> v3;</span><br><span class="line">    <span class="keyword">public</span>:   <span class="comment">//显示声明public</span></span><br><span class="line">        <span class="keyword">int</span> v2;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;       </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,<span class="string">&quot;Base&quot;</span>);</span><br><span class="line">    &#125;;    </span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Derived</span>:</span>Base &#123;         </span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="keyword">int</span> v2;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;       </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,<span class="string">&quot;Derived&quot;</span>);</span><br><span class="line">    &#125;;    </span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Base *b=<span class="keyword">new</span> <span class="built_in">Derived</span>();</span><br><span class="line">    b-&gt;<span class="built_in">print</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    
    <category term="cpp" scheme="http://example.com/tags/cpp/"/>
    
  </entry>
  
  <entry>
    <title>extern</title>
    <link href="http://example.com/2022/02/23/extern/"/>
    <id>http://example.com/2022/02/23/extern/</id>
    <published>2022-02-22T16:00:00.000Z</published>
    <updated>2022-03-06T14:30:53.935Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://gitee.com/zhuhaojia2001/pic_go_pics/raw/master/img/r_77251_3xSNn.jpg"></p><span id="more"></span><h1 id="extern"><a href="#extern" class="headerlink" title="extern"></a>extern</h1><p>在C++中常在头文件见到<code>extern &quot;C&quot;</code>修饰函数，是用于C++链接在C语言模块中定义的函数。<code>extern</code>用于标示变量或者函数的定义在别的文件中，<code>extern &quot;C&quot;</code>提示编译器遇到此变量和函数时在其他模块中寻找其定义告诉链接器去寻找<code>_add</code>这类的C语言符号，而不是经过C++修饰的符号。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//add.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ADD_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ADD_H</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//add.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;add.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x+y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//add.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;add.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">add</span>(<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码就会报错，因为相同的函数，在C和C++中，编译后生成的符号不同。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> &#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;add.h&quot;</span></span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">add</span>(<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译时需要通过gcc生成中间文件add.o</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -c add.c </span><br></pre></td></tr></table></figure><p>然后编译</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ add.cpp add.o -o main</span><br></pre></td></tr></table></figure><p>总结：</p><p>（1）C++调用C函数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//xx.h</span><br><span class="line">extern int add(...)</span><br><span class="line"></span><br><span class="line">//xx.c</span><br><span class="line">int add()&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//xx.cpp</span><br><span class="line">extern &quot;C&quot; &#123;</span><br><span class="line">    #include &quot;xx.h&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>C++确实是能够调用编译好的C函数</p><p>（2）C调用C++函数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//xx.h</span><br><span class="line">extern &quot;C&quot;&#123;</span><br><span class="line">    int add();</span><br><span class="line">&#125;</span><br><span class="line">//xx.cpp</span><br><span class="line">int add()&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">//xx.c</span><br><span class="line">extern int add();</span><br></pre></td></tr></table></figure><p>把C++代码当成C代码编译后调用。也就是说，C并不能直接调用C++库函数。</p><p><a href="https://www.cnblogs.com/yc_sunniwell/archive/2010/07/14/1777431.html">C/C++中extern关键字详解 - chao_yu - 博客园 (cnblogs.com)</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://gitee.com/zhuhaojia2001/pic_go_pics/raw/master/img/r_77251_3xSNn.jpg&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    
    <category term="cpp" scheme="http://example.com/tags/cpp/"/>
    
  </entry>
  
  <entry>
    <title>编译与链接</title>
    <link href="http://example.com/2022/02/08/%E7%BC%96%E8%AF%91%E4%B8%8E%E9%93%BE%E6%8E%A5/"/>
    <id>http://example.com/2022/02/08/%E7%BC%96%E8%AF%91%E4%B8%8E%E9%93%BE%E6%8E%A5/</id>
    <published>2022-02-07T16:00:00.000Z</published>
    <updated>2022-03-06T14:25:44.248Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://imgs.xkcd.com/comics/compiling.png"></p><span id="more"></span><h1 id="编译与链接"><a href="#编译与链接" class="headerlink" title="编译与链接"></a>编译与链接</h1><h2 id="编译与链接的过程"><a href="#编译与链接的过程" class="headerlink" title="编译与链接的过程"></a>编译与链接的过程</h2><p>预处理（Prepressing）、 编译（Compilation）、汇编（Assembly）和链接（Linking）</p><p><img src="https://gitee.com/zhuhaojia2001/pic_go_pics/raw/master/img/image-20220208103928489.png" alt="image-20220208103928489"></p><h3 id="预编译"><a href="#预编译" class="headerlink" title="预编译"></a>预编译</h3><p>首先是源代码文件<code>hello.c</code>和相关的头文件，如<code>stdio.h</code>等被预编译器预编译成一个.i文件。相当于如下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc –E hello.c –o hello.i</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cpp hello.c &gt; hello.i</span><br></pre></td></tr></table></figure><p>主要处理那些源代码文件中的以“#”开始的预编译指令。如 “#include”会把包含的文件插入到预编译指令的位置、“#define ”会展开所有宏定义等。</p><h3 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h3><p>把预处理完的文件进行一系列词法分析、语法分析、语义分析及优化后生产相应的汇编代码文件。相当于如下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc –S hello.i –o hello.s</span><br></pre></td></tr></table></figure><p>现在版本的GCC把预编译和编译两个步骤合并成一个步骤，使用一个叫做cc1的程序来完成这两个步骤</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc –S hello.c –o hello.s</span><br></pre></td></tr></table></figure><h3 id="汇编"><a href="#汇编" class="headerlink" title="汇编"></a>汇编</h3><p>将汇编代码转变成机器可以执行的指令，可以调用汇编器as来完成：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">as hello.s –o hello.o</span><br></pre></td></tr></table></figure><p>或者使用gcc命令经过预编译、编译和汇编直接输出目标文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc –c hello.c –o hello.o</span><br></pre></td></tr></table></figure><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p>一大堆文件链接起来才可以得到可执行文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ld -static /usr/lib/crt1.o /usr/lib/crti.o /usr/lib/gcc/i486-linux- gnu/4.1.3/crtbeginT.o -L/usr/lib/gcc/i486-linux-gnu/4.1.3 -L/usr/lib - L/lib hello.o --start-group -lgcc -lgcc_eh -lc --end-group /usr/lib/gcc/i486- linux-gnu/4.1.3/crtend.o /usr/lib/crtn.o</span><br></pre></td></tr></table></figure><p>后面会介绍为什么要链接这么多东西</p><h2 id="编译器"><a href="#编译器" class="headerlink" title="编译器"></a>编译器</h2><ul><li>词法分析</li><li>语法分析</li><li>语义分析</li><li>中间语言生成</li><li>目标代码生成与优化</li></ul><h2 id="链接器"><a href="#链接器" class="headerlink" title="链接器"></a>链接器</h2><p>很久以前人们写代码全写在一个文件中，直到后来没有能力维护一个程序。</p><p>链接器的历史比编译器还长</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://imgs.xkcd.com/comics/compiling.png&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    
    <category term="cpp" scheme="http://example.com/tags/cpp/"/>
    
  </entry>
  
  <entry>
    <title>抽象工厂</title>
    <link href="http://example.com/2022/01/28/%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82/"/>
    <id>http://example.com/2022/01/28/%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82/</id>
    <published>2022-01-27T16:00:00.000Z</published>
    <updated>2022-01-28T13:31:31.960Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://gitee.com/zhuhaojia2001/pic_go_pics/raw/master/img/image-20220128195659444.png" alt="image-20220128195659444"></p><span id="more"></span><h1 id="抽象工厂"><a href="#抽象工厂" class="headerlink" title="抽象工厂"></a>抽象工厂</h1><h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><p><img src="https://gitee.com/zhuhaojia2001/pic_go_pics/raw/master/img/image-20220128204736919.png" alt="image-20220128204736919"></p><ol><li><p> <strong>抽象产品</strong>（Abstract Product）为构成系列产品的一组不同但相关的产品声明接口。</p></li><li><p> <strong>具体产品</strong>（Concrete Product）是抽象产品的多种不同类型实现。所有变体（维多利亚/现代）都必须实现相应的抽象产品（椅子/沙发）。</p></li><li><p> <strong>抽象工厂</strong>（Abstract Factory）接口声明了一组创建各种抽象产品的方法。</p></li><li><p> <strong>具体工厂</strong>（Concrete Factory）实现抽象工厂的构建方法。每个具体工厂都对应特定产品变体，且仅创建此种产品变体。 </p></li><li><p>尽管具体工厂会对具体产品进行初始化，其构建方法签名必须返回相应的抽象产品。这样，使用工厂类的客户端代码就不会与工厂创建的特定产品变体耦合。<strong>客户端</strong>（Client）只需通过抽象接口调用工厂和产品对象，就能与任何具体工厂/产品变体交互。</p></li></ol><h2 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h2><ul><li><p>如果代码需要与多个不同系列的相关产品交互，但是由于无法提前获取相关信息，或者出于对未来扩展性的考虑，你不希望代码基于产品的具体类进行构建，在这种情况下，你可以使用抽象工厂。</p></li><li><p>如果你有一个基于一组抽象方法的类，且其主要功能因此变得不明确，那么在这种情况下可以考虑使用抽象工厂模式。</p></li></ul><h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><ul><li><p>Pros</p><ul><li><p>你可以确保同一工厂生成的产品相互匹配。</p></li><li><p>你可以避免客户端和具体产品代码的耦合。</p></li><li><p>单一职责原则。你可以将产品生成代码抽取到同一位置，使得代码易于维护。</p></li><li><p>开闭原则。向应用程序中引入新产品变体时，你无需修改客户端代码。</p></li></ul></li><li><p>Cons</p><ul><li>由于采用该模式需要向应用中引入众多接口和类，代码可能会比之前更加复杂</li></ul></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://gitee.com/zhuhaojia2001/pic_go_pics/raw/master/img/image-20220128195659444.png&quot; alt=&quot;image-20220128195659444&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    
    <category term="OOP" scheme="http://example.com/tags/OOP/"/>
    
    <category term="设计模式" scheme="http://example.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>工厂方法</title>
    <link href="http://example.com/2022/01/27/%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95/"/>
    <id>http://example.com/2022/01/27/%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95/</id>
    <published>2022-01-26T16:00:00.000Z</published>
    <updated>2022-01-27T12:59:04.025Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://gitee.com/zhuhaojia2001/pic_go_pics/raw/master/img/image-20220127110418853.png" alt="image-20220127110418853"></p><span id="more"></span><h1 id="工厂方法"><a href="#工厂方法" class="headerlink" title="工厂方法"></a>工厂方法</h1><h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><p><img src="https://gitee.com/zhuhaojia2001/pic_go_pics/raw/master/img/image-20220127152147123.png" alt="image-20220127152147123"></p><ol><li><p><strong>产品</strong>（Product）将会对接口进行声明。对于所有由创建者及其子类构建的对象，这些接口都是通用的。</p></li><li><p> <strong>具体产品</strong>（Concrete Products）是产品接口的不同实现。</p></li><li><p> <strong>创建者</strong>（Creator）类声明返回产品对象的工厂方法。该方法的返回对象类型必须与产品接口相匹配。 注意，尽管它的名字是创建者，但它最主要的职责并<strong>不是创建产品</strong>。一般来说，创建者类包含一些与产品相关的<strong>核心业务</strong>逻辑。工厂方法将这些逻辑处理从具体产品类中分离出来。打个比方，大型软件开发公司拥有程序员培训部门。但是，这些公司的主要工作还是编写代码，而非生产程序员。</p></li><li><p> <strong>具体创建者</strong>（Concrete Creators） 将会重写基础工厂方法，使其返回不同类型的产品。注意，并不一定每次调用工厂方法都会<strong>创建</strong>新的实例。工厂方法也可以返回缓存、对象池或其他来源的已有对象。</p></li></ol><h2 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h2><ul><li><p><strong>当你在编写代码的过程中，如果无法预知对象确切类别及其依赖关系时，可使用工厂方法</strong></p></li><li><p><strong>如果你希望用户能扩展你软件库或框架的内部组件，可使用工厂方法</strong></p></li><li><p><strong>如果你希望复用现有对象来节省系统资源，而不是每次都重新创建对象，可使用工厂方法</strong></p></li></ul><h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><ul><li><p>Pros</p><ul><li>你可以避免创建者和具体产品之间的紧密耦合。</li><li>单一职责原则。你可以将产品创建代码放在程序的单一位置，从而使得代码更容易维护。</li><li>开闭原则。无需更改现有客户端代码，你就可以在程序中引入新的产品类型。</li></ul></li><li><p>Cons</p><ul><li>应用工厂方法模式需要引入许多新的子类，代码可能会因此变得更复杂。最好的情况是将该模式引入创建者类的现有层次结构中。</li></ul></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://gitee.com/zhuhaojia2001/pic_go_pics/raw/master/img/image-20220127110418853.png&quot; alt=&quot;image-20220127110418853&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    
    <category term="OOP" scheme="http://example.com/tags/OOP/"/>
    
    <category term="设计模式" scheme="http://example.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>继承与多态</title>
    <link href="http://example.com/2022/01/25/%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/"/>
    <id>http://example.com/2022/01/25/%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/</id>
    <published>2022-01-24T16:00:00.000Z</published>
    <updated>2022-03-06T08:20:12.796Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.redd.it/yxgt7f3dr3831.jpg"></p><span id="more"></span><h1 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h1><h2 id="访问权限"><a href="#访问权限" class="headerlink" title="访问权限"></a>访问权限</h2><p>基类的保护成员可以在派生类的成员函数中被访问，派生类的成员函数只能访问所作用的那个对象（即this指针指向的对象）的基类保护成员，不能访问其他基类对象的基类保护成员。<br>$$<br>\begin{array}{|l|l|l|l|}<br>\hline \text { 类成员/继承方式 } &amp; \text { public继承 } &amp; \text { protected继承 } &amp; \text { private继承 } \<br>\hline \begin{array}{l}<br>\text { 基类的public成员 }<br>\end{array} &amp; \text { 派生类的public成员 } &amp; \text { 派生类的protected成员 } &amp; \text { 派生类的private成员 } \<br>\hline \begin{array}{l}<br>\text { 基类的protected成员 }<br>\end{array} &amp; \text { 派生类的protected成员 } &amp; \text { 派生类的protected成员 } &amp; \text { 派生类的private成员 } \<br>\hline \begin{array}{l}<br>\text { 基类的private成员 }<br>\end{array} &amp; \begin{array}{l}<br>\text { 不可见，只能通过基类接口访问 }<br>\end{array} &amp; \begin{array}{l}<br>\text { 不可见，只能通过基类接口访问 }<br>\end{array} &amp; \begin{array}{l}<br>\text { 不可见，只能通过基类接口访问 }<br>\end{array} \<br>\hline<br>\end{array}<br>$$<br>基类private成员在派生类中无论以什么方式继承都是不可见的。如果基类成员不想在类外直接访问，但需要在派生类中能访问，就定义为protected。<strong>可见，保护成员限定符protected是因为继承才出现的。</strong>class默认的继承方式是private，struct默认的继承方式是private。</p><p><strong>友元关系不能继承</strong>，也就是说基类友元不能访问子类私有和保护成员。</p><p><strong>基类定义了static静态成员，则整个继承体系里只有一个这样的成员。无论派生出多少个子类，都有一个static成员实例。</strong></p><h2 id="兼容性规则"><a href="#兼容性规则" class="headerlink" title="兼容性规则"></a>兼容性规则</h2><p>1.子类对象可以赋值给父类对象<br>2.父类对象不能赋值给子类对象<br>3.父类的指针/引用可以指向子类对象<br>4.子类的指针/引用不能指向父类对象（必须强转，但也只是改变父类里面有的东西）</p><p> <strong>派生类对象</strong>可以赋值给<strong>基类对象/基类的指针/基类的引用</strong>。这里有个形象的说法叫“切片”或者“切割”。<strong>寓意把派生类中父类那部分切来赋值过去</strong>。基类对象不能赋值给派生类对象。</p><h2 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h2><p>子类和父类中有同名成员，<strong>子类成员将屏蔽父类对同名成员的直接访问，这种情况叫“隐藏”，也叫“重定义”</strong>（在子类成员函数中，可以使用 <strong>基类::基类成员 显示访问</strong> ），但一般不会在子类和父类里命名同样名字的变量；</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Student的_num和Person的_num构成隐藏关系，可以看出这样的代码虽然能跑，但是非常容易混淆</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">string _name = <span class="string">&quot;小李子&quot;</span>; <span class="comment">//姓名</span></span><br><span class="line"><span class="keyword">int</span> _num = <span class="number">111</span>; <span class="comment">//身份证号</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> :</span><span class="keyword">public</span> Person</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Print</span><span class="params">()</span></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;姓名： &quot;</span> &lt;&lt; _name &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;身份证： &quot;</span> &lt;&lt; Person::_num &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;学号： &quot;</span> &lt;&lt; _num &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"><span class="keyword">int</span> _num = <span class="number">999</span>; <span class="comment">//学号</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Student s1;</span><br><span class="line">s1.<span class="built_in">Print</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="默认函数"><a href="#默认函数" class="headerlink" title="默认函数"></a>默认函数</h2><p><img src="https://img-blog.csdnimg.cn/20190603110911780.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3N0dWR5aGFyZGk=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>如果基类没有默认的构造函数，则必须在派生类构造函数的初始化列表阶段显示调用</p><p>from <a href="https://blog.csdn.net/studyhardi/article/details/90744785">(8条消息) C++中的继承_studyhardi的博客-CSDN博客_c++继承</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Person</span>(<span class="keyword">const</span> <span class="keyword">char</span>* name = <span class="string">&quot;Romeo&quot;</span>)</span><br><span class="line">:_name(name)&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Person()&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Person</span>(<span class="keyword">const</span> Person&amp; p)</span><br><span class="line">:_name(p._name)&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Person(const Person&amp; p)&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Person&amp; p)&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Person&amp; operator=(const Person&amp; p)&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span> != &amp;p)&#123;</span><br><span class="line">_name = p._name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">~<span class="built_in">Person</span>()&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;~Person()&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">string _name; <span class="comment">//姓名</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> :</span><span class="keyword">public</span> Person</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Student</span>(<span class="keyword">const</span> <span class="keyword">char</span>* name, <span class="keyword">int</span> num)</span><br><span class="line">:<span class="built_in">Person</span>(name) <span class="comment">//调用父类的构造函数完成从父类继承来的成员的初始化</span></span><br><span class="line">, _num(num)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Student()&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Student</span>(<span class="keyword">const</span> Student&amp; s)</span><br><span class="line">:<span class="built_in">Person</span>(s) <span class="comment">//调用父类的拷贝构造函数，其中也为“切片”操作，因为父类的拷贝构造函数的参数为引用</span></span><br><span class="line">, _num(s._num)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Student(const Student&amp; s)&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Student&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Student&amp; s)&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Student&amp; operator=(const Student&amp; s)&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span> != &amp;s)&#123;</span><br><span class="line">Person::<span class="keyword">operator</span>=(s);  <span class="comment">//调用基类的</span></span><br><span class="line">_num = s._num;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">~<span class="built_in">Student</span>()&#123;</span><br><span class="line"><span class="comment">//此处不需要显示调用父类的析构函数，编译器会自动调用</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;~Student()&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"><span class="keyword">int</span> _num; <span class="comment">//学号</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">Student <span class="title">s1</span><span class="params">(<span class="string">&quot;jack&quot;</span>, <span class="number">18</span>)</span></span>;</span><br><span class="line"><span class="function">Student <span class="title">s2</span><span class="params">(s1)</span></span>;</span><br><span class="line"><span class="function">Student <span class="title">s3</span><span class="params">(<span class="string">&quot;rose&quot;</span>, <span class="number">17</span>)</span></span>;</span><br><span class="line">s1 = s3;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">Test</span>();</span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h1><p>C++提供多态的目的是：可以通过基类指针对所有派生类（包括直接派生和间接派生）的成员变量和成员函数进行“全方位”的访问，尤其是成员函数。如果没有多态，我们只能访问成员变量。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://i.redd.it/yxgt7f3dr3831.jpg&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    
    <category term="cpp" scheme="http://example.com/tags/cpp/"/>
    
  </entry>
  
  <entry>
    <title>environment</title>
    <link href="http://example.com/2022/01/24/environment/"/>
    <id>http://example.com/2022/01/24/environment/</id>
    <published>2022-01-23T16:00:00.000Z</published>
    <updated>2022-03-06T14:07:11.012Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://imgs.xkcd.com/comics/python_environment.png"></p><span id="more"></span><h1 id="environment"><a href="#environment" class="headerlink" title="environment"></a>environment</h1><h2 id="镜像"><a href="#镜像" class="headerlink" title="镜像"></a>镜像</h2><h3 id="pip"><a href="#pip" class="headerlink" title="pip"></a>pip</h3><p>临时使用</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install -i https://pypi.tuna.tsinghua.edu.cn/simple some-package</span><br></pre></td></tr></table></figure><p>设为默认</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip config <span class="built_in">set</span> global.index-url https://pypi.tuna.tsinghua.edu.cn/simple</span><br></pre></td></tr></table></figure><h3 id="conda"><a href="#conda" class="headerlink" title="conda"></a>conda</h3><p>显示</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda config --show channels</span><br></pre></td></tr></table></figure><p>添加</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/</span><br><span class="line">conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main/</span><br><span class="line">conda config --<span class="built_in">set</span> show_channel_urls yes</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://imgs.xkcd.com/comics/python_environment.png&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    
    <category term="python" scheme="http://example.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>exceptions</title>
    <link href="http://example.com/2022/01/23/exceptions/"/>
    <id>http://example.com/2022/01/23/exceptions/</id>
    <published>2022-01-22T16:00:00.000Z</published>
    <updated>2022-03-06T11:54:29.786Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://miro.medium.com/max/400/1*LaiblpVE0dAZbMXSgCvrLQ.jpeg"></p><span id="more"></span><h1 id="exceptions"><a href="#exceptions" class="headerlink" title="exceptions"></a>exceptions</h1><p>捕获异常</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="comment">// 可能抛出异常的语句</span></span><br><span class="line">&#125;<span class="built_in"><span class="keyword">catch</span></span>(exceptionType variable)&#123;</span><br><span class="line">    <span class="comment">// 处理异常的语句</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>exceptionType</code>指明了可以处理的异常类型。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;exception&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    string str = <span class="string">&quot;http://c.biancheng.net&quot;</span>;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="keyword">char</span> ch1 = str[<span class="number">100</span>];</span><br><span class="line">        cout&lt;&lt;ch1&lt;&lt;endl;</span><br><span class="line">    &#125;<span class="built_in"><span class="keyword">catch</span></span>(exception e)&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;[1]out of bound!&quot;</span>&lt;&lt;endl; <span class="comment">//检测不到异常</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="keyword">char</span> ch2 = str.<span class="built_in">at</span>(<span class="number">100</span>);</span><br><span class="line">        cout&lt;&lt;ch2&lt;&lt;endl;</span><br><span class="line">    &#125;<span class="built_in"><span class="keyword">catch</span></span>(exception &amp;e)&#123;  <span class="comment">//exception类位于&lt;exception&gt;头文件中</span></span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;[2]out of bound!&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>发生异常时必须将异常明确地抛出，try 才能检测到；如果不抛出来，即使有异常 try 也检测不到。</p><p>异常一旦抛出，会立刻被 try 检测到，并且不会再执行异常点（异常发生位置）后面的语句，而是直接跳转到<code>catch</code>后面。</p><p>（不要使用）throw 用作异常规范：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">func</span> <span class="params">(<span class="keyword">char</span> param)</span> <span class="title">throw</span> <span class="params">(<span class="keyword">int</span>, <span class="keyword">char</span>, exception)</span></span>;</span><br></pre></td></tr></table></figure><p>抛出其他类型的异常，try 将无法捕获，只能终止程序。</p><p>各种异常</p><p><img src="https://gitee.com/zhuhaojia2001/pic_go_pics/raw/master/img/114Q24150-0.jpg" alt="C++ exception类层次图"></p><p>exception 类的直接派生类：</p><table><thead><tr><th>异常名称</th><th>说  明</th></tr></thead><tbody><tr><td>logic_error</td><td>逻辑错误。</td></tr><tr><td>runtime_error</td><td>运行时错误。</td></tr><tr><td>bad_alloc</td><td>使用 new 或 new[ ] 分配内存失败时抛出的异常。</td></tr><tr><td>bad_typeid</td><td>使用 typeid 操作一个 NULL <a href="http://c.biancheng.net/c/80/">指针</a>，而且该指针是带有虚函数的类，这时抛出 bad_typeid 异常。</td></tr><tr><td>bad_cast</td><td>使用 dynamic_cast 转换失败时抛出的异常。</td></tr><tr><td>ios_base::failure</td><td>io 过程中出现的异常。</td></tr><tr><td>bad_exception</td><td>这是个特殊的异常，如果函数的异常列表里声明了 bad_exception 异常，当函数内部抛出了异常列表中没有的异常时，如果调用的 unexpected() 函数中抛出了异常，不论什么类型，都会被替换为 bad_exception 类型。</td></tr></tbody></table><p>  logic_error 的派生类： </p><table><thead><tr><th>异常名称</th><th>说  明</th></tr></thead><tbody><tr><td>length_error</td><td>试图生成一个超出该类型最大长度的对象时抛出该异常，例如 vector 的 resize 操作。</td></tr><tr><td>domain_error</td><td>参数的值域错误，主要用在数学函数中，例如使用一个负值调用只能操作非负数的函数。</td></tr><tr><td>out_of_range</td><td>超出有效范围。</td></tr><tr><td>invalid_argument</td><td>参数不合适。在标准库中，当利用string对象构造 bitset 时，而 string 中的字符不是 0 或1 的时候，抛出该异常。</td></tr></tbody></table><p>runtime_error 的派生类： </p><table><thead><tr><th>异常名称</th><th>说  明</th></tr></thead><tbody><tr><td>range_error</td><td>计算结果超出了有意义的值域范围。</td></tr><tr><td>overflow_error</td><td>算术计算上溢。</td></tr><tr><td>underflow_error</td><td>算术计算下溢。</td></tr></tbody></table><p>from <a href="http://c.biancheng.net/view/2333.html">C++ exception类：C++标准异常的基类 (biancheng.net)</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://miro.medium.com/max/400/1*LaiblpVE0dAZbMXSgCvrLQ.jpeg&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    
    <category term="cpp" scheme="http://example.com/tags/cpp/"/>
    
  </entry>
  
  <entry>
    <title>OOP与设计模式</title>
    <link href="http://example.com/2022/01/22/OOP%E4%B8%8E%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <id>http://example.com/2022/01/22/OOP%E4%B8%8E%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</id>
    <published>2022-01-21T16:00:00.000Z</published>
    <updated>2022-01-27T10:40:05.200Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://qph.fs.quoracdn.net/main-qimg-2d9b082048e2a7a93a1e6199c9c70ee3-lq"></p><span id="more"></span><h1 id="OOP与设计模式"><a href="#OOP与设计模式" class="headerlink" title="OOP与设计模式"></a>OOP与设计模式</h1><ul><li><p>抽象：是一种反映真实世界对象或现象中特定内容的模型，它能高精度地反映所有与特定内容相关的详细信息，同时忽略其他内容。</p></li><li><p>封装：指一个对象对其他对象隐藏其部分状态和行为，而仅向程序其他部分暴露有限的接口的能力。绝大部分编程语言的接口和抽象类（或方法）都基于抽象和封装的概念。</p></li><li><p>继承：是指在根据已有类创建新类的能力。</p></li><li><p>多态：指程序能够检测对象所属的实际类，并在当前上下文不知道其真实类型的情况下调用其实现的能力。</p></li></ul><h2 id="对象与类的关系"><a href="#对象与类的关系" class="headerlink" title="对象与类的关系"></a>对象与类的关系</h2><p><img src="https://gitee.com/zhuhaojia2001/pic_go_pics/raw/master/img/image-20220125145545504.png" alt="image-20220125145545504"></p><ul><li><p><strong>依赖</strong>：对类 B 进行修改会影响到类 A 。 </p></li><li><p><strong>关联</strong>：对象 A 知道对象 B。类 A 依赖于类 B。</p></li><li><p><strong>聚合</strong>：对象 A 知道对象 B 且由 B 构成。类 A 依赖于类 B。 </p></li><li><p><strong>组合</strong>：对象 A 知道对象 B、由 B 构成而且管理着 B 的生命周期。类 A 依赖于类 B。 </p></li><li><p><strong>实现</strong>：类 A 定义的方法由接口 B 声明。对象 A 可被视为对象B。类 A 依赖于类 B。 </p></li><li><p><strong>继承</strong>： 类 A 继承类 B 的接口和实现， 但是可以对其进行扩展。对象 A 可被视为对象 B。类 A 依赖于类 B。</p></li></ul><h2 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h2><ul><li><p><strong>创建型模式</strong>提供创建对象的机制，增加已有代码的灵活性和可复用性。 </p></li><li><p><strong>结构型模式</strong>介绍如何将对象和类组装成较大的结构，并同时保持结构的灵活和高效。 </p></li><li><p><strong>行为模式</strong>负责对象间的高效沟通和职责委派。</p></li></ul><h2 id="优秀设计"><a href="#优秀设计" class="headerlink" title="优秀设计"></a>优秀设计</h2><ul><li>代码复用<ul><li>类，容器</li><li>模式</li><li>框架</li></ul></li><li>扩展性<ul><li>移植</li><li>扩展</li><li>改变</li></ul></li></ul><h2 id="SOLID原则"><a href="#SOLID原则" class="headerlink" title="SOLID原则"></a>SOLID原则</h2><h3 id="S-ingle-Responsibility-Principle-单一职责原则"><a href="#S-ingle-Responsibility-Principle-单一职责原则" class="headerlink" title="[S]ingle Responsibility Principle 单一职责原则"></a>[S]ingle Responsibility Principle 单一职责原则</h3><ul><li>尽量让每个类只负责软件中的一个功能，并将该功能完全封装（你也可称之为隐藏）在该类中。</li></ul><p><img src="https://gitee.com/zhuhaojia2001/pic_go_pics/raw/master/img/image-20220126105401639.png" alt="image-20220126105401639"></p><p><img src="https://gitee.com/zhuhaojia2001/pic_go_pics/raw/master/img/image-20220126105413092.png" alt="image-20220126105413092"></p><p>###[O]pen/Closed Principle 开闭原则</p><ul><li>在实现新功能时能保持已有代码不变。</li><li>对于扩展，类应该是“开放”的；对于修改，类则应是“封闭”的。</li></ul><p><img src="https://gitee.com/zhuhaojia2001/pic_go_pics/raw/master/img/image-20220126141335431.png" alt="image-20220126141335431"></p><p><img src="https://gitee.com/zhuhaojia2001/pic_go_pics/raw/master/img/image-20220126141348322.png" alt="image-20220126141348322"></p><h3 id="L-iskov-Substitution-Principle-里氏替换原则"><a href="#L-iskov-Substitution-Principle-里氏替换原则" class="headerlink" title="[L]iskov Substitution Principle 里氏替换原则"></a>[L]iskov Substitution Principle 里氏替换原则</h3><ul><li>子类方法的参数类型必须与其超类的参数类型相匹配或更加抽象</li><li>子类方法的返回值类型必须与超类方法的返回值类型或是其子类别相匹配</li><li>子类中的方法不应抛出基础方法预期之外的异常类型</li><li>子类不应该加强其前置条件</li><li>子类不能削弱其后置条</li><li>超类的不变量必须</li><li>子类不能修改超类中私有成员变量的值</li></ul><h3 id="I-nterface-Segregation-Principle-接口隔离原则"><a href="#I-nterface-Segregation-Principle-接口隔离原则" class="headerlink" title="[I]nterface Segregation Principle 接口隔离原则"></a>[I]nterface Segregation Principle 接口隔离原则</h3><ul><li>尽量缩小接口的范围，使得客户端的类不必实现其不需要的行为</li></ul><p><img src="https://gitee.com/zhuhaojia2001/pic_go_pics/raw/master/img/image-20220126160857817.png" alt="image-20220126160857817"></p><p><img src="https://gitee.com/zhuhaojia2001/pic_go_pics/raw/master/img/image-20220126160907977.png" alt="image-20220126160907977"></p><h3 id="D-ependency-Inversion-principle-依赖倒置原则"><a href="#D-ependency-Inversion-principle-依赖倒置原则" class="headerlink" title="[D]ependency Inversion principle 依赖倒置原则"></a>[D]ependency Inversion principle 依赖倒置原则</h3><ul><li><p>高层次的类不应该依赖于低层次的类。 两者都应该依赖于抽象接口。抽象接口不应依赖于具体实现。具体实现应该依赖于抽象接口</p><ul><li><p><strong>低层次的类</strong>实现基础操作（例如磁盘操作、传输网络数据和连接数据库等）。</p></li><li><p><strong>高层次类</strong>包含复杂业务逻辑以指导低层次类执行特定操作。</p></li></ul></li></ul><p><img src="https://gitee.com/zhuhaojia2001/pic_go_pics/raw/master/img/image-20220126161103850.png" alt="image-20220126161103850"></p><p><img src="https://gitee.com/zhuhaojia2001/pic_go_pics/raw/master/img/image-20220126161112244.png" alt="image-20220126161112244"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://qph.fs.quoracdn.net/main-qimg-2d9b082048e2a7a93a1e6199c9c70ee3-lq&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    
    <category term="OOP" scheme="http://example.com/tags/OOP/"/>
    
    <category term="设计模式" scheme="http://example.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>位域</title>
    <link href="http://example.com/2022/01/22/%E4%BD%8D%E5%9F%9F/"/>
    <id>http://example.com/2022/01/22/%E4%BD%8D%E5%9F%9F/</id>
    <published>2022-01-21T16:00:00.000Z</published>
    <updated>2022-03-01T09:38:02.345Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.redd.it/8ceh0d66fdz51.jpg"><span id="more"></span></p><h1 id="位域"><a href="#位域" class="headerlink" title="位域"></a>位域</h1><p>“ 位域 “ 或 “ 位段 “(Bit field)为一种数据结构，可以把数据以位的形式紧凑的储存，并允许程序员对此结构的位进行操作。这种数据结构的一个好处是它可以使数据单元节省储存空间，当程序需要成千上万个数据单元时，这种方法就显得尤为重要。第二个好处是位段可以很方便的访问一个整数值的部分内容从而可以简化程序源代码。而这种数据结构的缺点在于，位段实现<strong>依赖于具体的机器和系统</strong>，在不同的平台可能有不同的结果，这导致了位段在本质上是<strong>不可移植的</strong>。</p><h2 id="声明方法"><a href="#声明方法" class="headerlink" title="声明方法"></a>声明方法</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bit_field_name</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    type member_name : width;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">PRCODE</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> code1: <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> cdde2: <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> code3: <span class="number">8</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">PRCODE</span> <span class="title">prcode</span>;</span></span><br><span class="line"></span><br><span class="line">prcode.code1 = <span class="number">0</span>;</span><br><span class="line">prcode.code2 = <span class="number">3</span>;</span><br><span class="line">procde.code3 = <span class="number">102</span>;</span><br></pre></td></tr></table></figure><p>赋值时要注意值的大小不能超过位域成员的容量，例如 prcode.code3 为 8 Bits 的位域成员，其容量为 2^8 = 256，即赋值范围应为 [0,255]。</p><h2 id="位域的对齐"><a href="#位域的对齐" class="headerlink" title="位域的对齐"></a>位域的对齐</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stuff</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> field1: <span class="number">30</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> field2: <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> field3: <span class="number">3</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>field1</code> + <code>field2</code> = 34 Bits，超出 32 Bits, 编译器会将<code>field2</code>移位至下一个 unsigned int 单元存放， stuff.field1 和 stuff.field2 之间会留下一个 2 Bits 的空隙， stuff.field3 紧跟在 stuff.field2 之后，该结构现在大小为 2 * 32 = 64 Bits。</p><p>这个空洞可以用之前提到的未命名的位域成员填充，我们也可以使用一个宽度为 0 的未命名位域成员令下一位域成员与下一个整数对齐。 例如:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stuff</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> field1: <span class="number">30</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span>       : <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> field2: <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span>       : <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> field3: <span class="number">3</span>; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h2><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">struct stuff s1= &#123;20,8,6&#125;;</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stuff</span> <span class="title">s1</span>;</span></span><br><span class="line">s1.field1 = <span class="number">20</span>;</span><br><span class="line">s1.field2 = <span class="number">8</span>;</span><br><span class="line">s1.field3 = <span class="number">4</span>;</span><br></pre></td></tr></table></figure><h3 id="重映射"><a href="#重映射" class="headerlink" title="重映射"></a>重映射</h3><p>声明一个 大小为 32 Bits 的位域</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">box</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> ready:     <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> error:     <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> command:   <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> sector_no: <span class="number">24</span>;</span><br><span class="line">&#125;b1;</span><br></pre></td></tr></table></figure><p>利用重映射将位域归零</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>* p = (<span class="keyword">int</span> *) &amp;b1;  <span class="comment">// 将 &quot;位域结构体的地址&quot; 映射至 &quot;整形（int*) 的地址&quot; </span></span><br><span class="line">*p = <span class="number">0</span>;                <span class="comment">// 清除 s1，将各成员归零</span></span><br></pre></td></tr></table></figure><p>利用联合 (union) 将 32 Bits 位域重映射至 unsigned int 型。在任意时刻，联合中只能有一个数据成员可以有值。当给联合中某个成员赋值之后，该联合中的其它成员就变成未定义状态了。union的size就是最大的内部组件大小。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">u_box</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">box</span> <span class="title">st_box</span>;</span>     </span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> ui_box;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>联合（union）是一种节省空间的特殊的类，一个 union 可以有多个数据成员，但是在任意时刻只有一个数据成员可以有值。当某个成员被赋值后其他成员变为未定义状态。联合有如下特点：</p><ul><li>默认访问控制符为 public</li><li>可以含有构造函数、析构函数</li><li>不能含有引用类型的成员</li><li>不能继承自其他类，不能作为基类</li><li>不能含有虚函数</li><li>匿名 union 在定义所在作用域可直接访问 union 成员</li><li>匿名 union 不能包含 protected 成员或 private 成员</li><li>全局匿名联合必须是静态（static）的</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://i.redd.it/8ceh0d66fdz51.jpg&quot;&gt;</summary>
    
    
    
    
    <category term="cpp" scheme="http://example.com/tags/cpp/"/>
    
  </entry>
  
  <entry>
    <title>volatile and assert</title>
    <link href="http://example.com/2022/01/21/volatile%20and%20assert/"/>
    <id>http://example.com/2022/01/21/volatile%20and%20assert/</id>
    <published>2022-01-20T16:00:00.000Z</published>
    <updated>2022-01-21T14:55:21.659Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://www.explainxkcd.com/wiki/images/3/3a/forgetting.png"></p><span id="more"></span><h1 id="volatile-and-assert"><a href="#volatile-and-assert" class="headerlink" title="volatile and assert"></a>volatile and assert</h1><h2 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h2><p>被 <code>volatile</code> 修饰的变量，在对其进行读写操作时，会引发一些<strong>可观测的副作用</strong>。而这些可观测的副作用，是由<strong>程序之外的因素决定的</strong>。</p><p><code>volatile</code> 会在编译的时候优化一些它认为无效的操作</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>  *output = (<span class="keyword">unsigned</span>  <span class="keyword">int</span> *)<span class="number">0xff800000</span>; <span class="comment">//定义一个IO端口；  </span></span><br><span class="line"><span class="function"><span class="keyword">int</span>   <span class="title">init</span><span class="params">(<span class="keyword">void</span>)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">int</span> i;  </span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt; <span class="number">10</span>;i++)</span><br><span class="line">    &#123;  </span><br><span class="line">    *output = i;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 编译器会直接优化为</span></span><br><span class="line"><span class="function"><span class="keyword">int</span>  <span class="title">init</span><span class="params">(<span class="keyword">void</span>)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    *output = <span class="number">9</span>;  </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 但有些情况不希望这种优化发生</span></span><br></pre></td></tr></table></figure><p>volatile通知编译器这个变量是一个不稳定的，在遇到此变量时候不要优化。</p><p>多线程应用中被多个任务共享的变量。 当多个线程共享某一个变量时，该变量的值会被某一个线程更改，应该用 volatile 声明。作用是防止编译器优化把变量从内存装入CPU寄存器中，当一个线程更改变量后，未及时同步到其它线程中导致程序出错。volatile的意思是让编译器每次操作该变量时一定要从内存中真正取出，而不是使用已经存在寄存器中的值。示例如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">volatile</span>  <span class="keyword">bool</span> bStop=<span class="literal">false</span>;  <span class="comment">//bStop 为共享全局变量  </span></span><br><span class="line"><span class="comment">//第一个线程</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">threadFunc1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">while</span>(!bStop)&#123;...&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//第二个线程终止上面的线程循环</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">threadFunc2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    bStop = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="assert"><a href="#assert" class="headerlink" title="assert"></a>assert</h2><p>断言，<strong>是宏，而非函数</strong>。assert 宏的原型定义在 （C）、（C++）中，其作用是如果它的条件返回错误，则终止程序执行。ASSERT 只有在 Debug 版本中才有效，可以通过定义 NDEBUG 来关闭 assert，但是需要在源代码的开头，include 之前。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NDEBUG  </span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://www.explainxkcd.com/wiki/images/3/3a/forgetting.png&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    
    <category term="cpp" scheme="http://example.com/tags/cpp/"/>
    
  </entry>
  
  <entry>
    <title>vtable and vptr</title>
    <link href="http://example.com/2022/01/20/vtable%20and%20vptr/"/>
    <id>http://example.com/2022/01/20/vtable%20and%20vptr/</id>
    <published>2022-01-19T16:00:00.000Z</published>
    <updated>2022-03-06T11:12:25.820Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://koenig-media.raywenderlich.com/uploads/2014/01/pic3.png"></p><span id="more"></span><h1 id="vtable-and-vptr"><a href="#vtable-and-vptr" class="headerlink" title="vtable and vptr"></a>vtable and vptr</h1><p>为了实现虚函数，C++使用一种称为虚拟表的特殊形式的后期绑定。该虚拟表是用于解决在动态/后期绑定方式的函数调用函数的查找表。虚拟表有时会使用其他名称，例如“vtable”，“虚函数表”，“虚方法表”或“调度表”。</p><p>虚拟表实际上非常简单，虽然用文字描述有点复杂。首先，<strong>每个使用虚函数的类（或者从使用虚函数的类派生）都有自己的虚拟表</strong>。该表只是编译器在编译时设置的静态数组。虚拟表包含可由类的对象调用的每个虚函数的一个条目。此表中的每个条目只是一个函数指针，指向该类可访问的派生函数。</p><p>其次，编译器还会添加一个<strong>隐藏指向基类</strong>的指针，我们称之为vptr。vptr在创建类实例时自动设置，以便指向该类的虚拟表。与this指针不同，this指针实际上是编译器用来解析自引用的函数参数，vptr是一个真正的指针。</p><p>因此，它使每个类对象的分配大一个指针的大小。这也意味着vptr由派生类继承，这很重要。</p><p>C++的动态多态性是通过虚函数来实现的。简单的说，通过virtual函数，指向子类的基类指针可以调用子类的函数。</p><p><a href="https://blog.csdn.net/haoel/article/details/1948051"> C++ 虚函数表解析_陈皓专栏　【空谷幽兰，心如皓月】-CSDN博客_虚函数表</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;Base::f&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">g</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;Base::g&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">h</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;Base::h&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/zhuhaojia2001/pic_go_pics/raw/master/img/o_vtable1.jpg" alt="img"></p><p>包含纯虚函数的类称为抽象类（Abstract Class）。之所以说它抽象，是因为它无法实例化，也就是无法创建对象。纯虚函数没有函数体，只有函数声明，在虚函数声明的结尾加上<code>=0</code>，表明此函数为纯虚函数。纯虚函数没有函数体，不是完整的函数，无法调用，也无法为其分配内存空间。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://koenig-media.raywenderlich.com/uploads/2014/01/pic3.png&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    
    <category term="cpp" scheme="http://example.com/tags/cpp/"/>
    
  </entry>
  
  <entry>
    <title>this and inline</title>
    <link href="http://example.com/2022/01/19/this%20and%20inline/"/>
    <id>http://example.com/2022/01/19/this%20and%20inline/</id>
    <published>2022-01-18T16:00:00.000Z</published>
    <updated>2022-01-21T02:16:39.318Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://imgs.xkcd.com/comics/pointers.png"></p><span id="more"></span><h1 id="this-and-inline"><a href="#this-and-inline" class="headerlink" title="this and inline"></a>this and inline</h1><h2 id="this"><a href="#this" class="headerlink" title="this"></a>this</h2><ul><li><p>一个对象的this指针并不是对象本身的一部分，不会影响sizeof(对象)的结果</p></li><li><p>在类的非静态成员函数中返回类对象本身的时候，直接使用 return *this</p></li><li><p>this作用域是在类内部，当在类的非静态成员函数中访问类的非静态成员的时候，编译器会自动将对象本身的地址作为一个隐含参数传递给函数。也就是说，即使你没有写上this指针，编译器在编译的时候也是加上this的，它作为非静态成员函数的隐含形参，对各成员的访问均通过this进行。</p></li><li><p>this在成员函数的开始执行前构造，在成员的执行结束后清除。</p></li></ul><h2 id="inline"><a href="#inline" class="headerlink" title="inline"></a>inline</h2><p>为了解决一些频繁调用的小函数大量消耗栈空间（栈内存）的问题，特别的引入了 <code>inline</code> 修饰符，表示为内联函数。</p><h4 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h4><ol><li><p>inline 定义的类的内联函数，函数的代码被放入符号表中，在使用时直接进行替换，（像宏一样展开），<strong>没有了调用的开销，效率也很高</strong>。</p></li><li><p>很明显，类的内联函数也是一个真正的函数，编译器在调用一个内联函数时，会首先检查它的参数的类型，保证调用正确。然后进行一系列的相关检查，就像对待任何一个真正的函数一样。这样就消除了它的隐患和局限性。（宏替换不会检查参数类型，安全隐患较大）。</p></li><li><p>inline函数可以作为一个类的成员函数，与类的普通成员函数作用相同，可以访问一个类的私有成员和保护成员。内联函数可以用于替代一般的宏定义，最重要的应用在于类的存取函数的定义上面。</p></li></ol><h4 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h4><ol><li>如果函数体内出现循环，那么执行函数体内代码的时间要比函数调用的开销大。</li><li>每一处内联函数的调用都要复制代码，将使程序的总代码量增大，消耗更多的内存空间。</li></ol><p>内联函数具有一定的局限性，内联函数的函数体一般来说不能太大，如果内联函数的函数体过大，一般的编译器会放弃内联方式，而采用普通的方式调用函数。inline说明对编译器来说只是一种建议，编译器可以选择忽略这个建议。比如，你将一个长达1000多行的函数指定为inline，编译器就会忽略这个inline，将这个函数还原成普通函数，因此并不是说把一个函数定义为inline函数就一定会被编译器识别为内联函数，具体取决于编译器的实现和函数体的大小。</p><p>注意事项：</p><ul><li>虚函数可以是内联函数，内联是可以修饰虚函数的，但是当虚函数表现多态性的时候不能内联。内联是在编译器建议编译器内联，而虚函数的多态性在运行期，编译器无法知道运行期调用哪个代码，因此虚函数表现为多态性时（运行期）不可以内联。</li><li><code>inline virtual</code> 唯一可以内联的时候是：编译器知道所调用的对象是哪个类，这只有在编译器具有实际对象而不是对象的指针或引用时才会发生。</li></ul><p>from <a href="https://www.cnblogs.com/chenwx-jay/p/inline_cpp.html">c++内联函数解析（inline） - 晴天Jay_chen - 博客园 (cnblogs.com)</a></p><h4 id="类中的成员函数与inline"><a href="#类中的成员函数与inline" class="headerlink" title="类中的成员函数与inline"></a>类中的成员函数与inline</h4><p><strong>定义</strong>在类中的<strong>成员函数</strong>默认都是<strong>内联的</strong>，如果在类定义时就在类内给出函数定义，那当然最好。如果在类中未给出成员函数定义，而又想内联该函数的话，那在类外要加上 <strong>inline</strong>，否则就认为不是内联的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 头文件</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Foo</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Foo1</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;&#125;; <span class="comment">// 自动成为内联函数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义文件</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">A::Foo</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://imgs.xkcd.com/comics/pointers.png&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    
    <category term="cpp" scheme="http://example.com/tags/cpp/"/>
    
  </entry>
  
  <entry>
    <title>vtable and vptr</title>
    <link href="http://example.com/2022/01/18/function%20pointer/"/>
    <id>http://example.com/2022/01/18/function%20pointer/</id>
    <published>2022-01-17T16:00:00.000Z</published>
    <updated>2022-01-20T13:50:23.833Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://hackaday.com/wp-content/uploads/2018/04/cpointers.jpg"></p><span id="more"></span><h1 id="Function-Pointer"><a href="#Function-Pointer" class="headerlink" title="Function Pointer"></a>Function Pointer</h1><p>定义形式<strong>：返回类型 （类名称::*函数成员名称）（参数类型，参数类型，参数类型，….);</strong> </p><p>1、函数指针变量跟普通的指针一样在32位系统下大小都为4。但是函数指针常量的大小为1.</p><p>2、函数指针变量和函数指针常量存储在内存的不同位置。</p><p>3、为负值的函数指针变量（全局）的值为0。</p><p><a href="https://www.cnblogs.com/windlaughing/archive/2013/04/10/3012012.html">深入理解C语言函数指针 - windlaughing - 博客园 (cnblogs.com)</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fun1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;this is fun1 call\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun2</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">char</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;this is fun2 call:%d %c\n&quot;</span>, k, c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in"><span class="keyword">int</span></span> (*pfun1)() = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in"><span class="keyword">void</span></span> (*pfun2)(<span class="keyword">int</span>, <span class="keyword">char</span>) = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">int</span> a,b;</span><br><span class="line">    pfun1 = fun1; <span class="comment">//第一种赋值方法</span></span><br><span class="line">    a = <span class="built_in">pfun1</span>();  <span class="comment">//第一种调用方法（推荐）</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,a);</span><br><span class="line">    b = (*pfun1)();<span class="comment">//第二种调用方法</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,b);</span><br><span class="line">    pfun2 = &amp;fun2;<span class="comment">//第二种赋值方法（推荐，因为和其他数据指针赋值方法一致）</span></span><br><span class="line">    <span class="built_in">pfun2</span>(<span class="number">1</span>,<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">    (*pfun2)(<span class="number">2</span>,<span class="string">&#x27;b&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数指针数组：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">add</span><span class="params">(<span class="keyword">float</span> a,<span class="keyword">float</span> b)</span></span>&#123;<span class="keyword">return</span> a+b;&#125;</span><br><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">minu</span><span class="params">(<span class="keyword">float</span> a,<span class="keyword">float</span> b)</span></span>&#123;<span class="keyword">return</span> a-b;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//定义一个函数指针数组，大小为2</span></span><br><span class="line">    <span class="comment">//里面存放float (*)(float, float)类型的指针</span></span><br><span class="line">    <span class="built_in"><span class="keyword">float</span></span> (*pfunArry[<span class="number">2</span>])(<span class="keyword">float</span>, <span class="keyword">float</span>) = &#123;&amp;add, &amp;minu&#125;;</span><br><span class="line">    <span class="keyword">double</span> k = pfunArry[<span class="number">0</span>](<span class="number">3.33</span>,<span class="number">2.22</span>);<span class="comment">// 调用</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%f\n&quot;</span>, k);</span><br><span class="line">    k = pfunArry[<span class="number">1</span>](<span class="number">3.33</span>,<span class="number">2.22</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%f\n&quot;</span>, k);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://hackaday.com/wp-content/uploads/2018/04/cpointers.jpg&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    
    <category term="cpp" scheme="http://example.com/tags/cpp/"/>
    
  </entry>
  
  <entry>
    <title>sizeof and virtual</title>
    <link href="http://example.com/2022/01/18/sizeof%20and%20virtual/"/>
    <id>http://example.com/2022/01/18/sizeof%20and%20virtual/</id>
    <published>2022-01-17T16:00:00.000Z</published>
    <updated>2022-01-20T14:53:05.883Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.redd.it/zlirmbdar7b71.png"></p><span id="more"></span><h1 id="sizeof-and-virtual"><a href="#sizeof-and-virtual" class="headerlink" title="sizeof and virtual"></a>sizeof and virtual</h1><h2 id="sizeof"><a href="#sizeof" class="headerlink" title="sizeof"></a>sizeof</h2><ul><li>空类的大小为1字节</li><li>一个类中，虚函数本身、成员函数（包括静态与非静态）和静态数据成员都是不占用类对象的存储空间。</li><li>对于包含虚函数的类，不管有多少个虚函数，只有一个虚指针。</li><li>普通继承，派生类继承了所有基类的函数与成员，要按照字节对齐来计算大小</li><li>虚函数继承，不管是单继承还是多继承，都是继承了基类的vptr。(32位操作系统4字节，64位操作系统 8字节)！</li><li>虚继承，继承基类的vptr。</li></ul><h2 id="virtual"><a href="#virtual" class="headerlink" title="virtual"></a>virtual</h2><p>纯虚函数，通过定义的时候赋值0来声明，包含纯虚函数的类为抽象类，抽象类不能创建对象但可以定义抽象类的指针。<strong>虚函数的调用取决于指向或者引用的对象的类型，而不是指针或者引用自身的类型。</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 抽象类至少包含一个纯虚函数</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>= <span class="number">0</span>; <span class="comment">// 纯虚函数</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getX</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> x; &#125; <span class="comment">// 普通成员函数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">     <span class="keyword">int</span> x; </span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> :</span> <span class="keyword">public</span> Base &#123; </span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;In Derived \n&quot;</span>; &#125; <span class="comment">// 实现抽象类的纯虚函数</span></span><br><span class="line">    <span class="built_in">Derived</span>()&#123;&#125; <span class="comment">// 构造函数</span></span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="comment">//Base b;  // error! 不能创建抽象类的对象</span></span><br><span class="line">    <span class="comment">//Base *b = new Base(); error!</span></span><br><span class="line">    </span><br><span class="line">    Base *bp = <span class="keyword">new</span> <span class="built_in">Derived</span>(); <span class="comment">// 抽象类的指针和引用 -&gt; 由抽象类派生出来的类的对象</span></span><br><span class="line">    bp-&gt;<span class="built_in">show</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>抽象类可以有构造函数</p><p>构造函数不能是虚函数，而析构函数可以是虚析构函数</p><p><strong>静态函数不可以声明为虚函数，同时也不能被const 和 volatile关键字修饰</strong>，static成员函数不属于任何类对象或类实例，所以即使给此函数加上virutal也是没有任何意义</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://i.redd.it/zlirmbdar7b71.png&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    
    <category term="cpp" scheme="http://example.com/tags/cpp/"/>
    
  </entry>
  
  <entry>
    <title>static</title>
    <link href="http://example.com/2022/01/18/static/"/>
    <id>http://example.com/2022/01/18/static/</id>
    <published>2022-01-17T16:00:00.000Z</published>
    <updated>2022-01-18T07:51:11.080Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://pbs.twimg.com/media/EYyrqtIWoAAjgNv.jpg"></p><span id="more"></span><h1 id="static"><a href="#static" class="headerlink" title="static"></a>static</h1><h3 id="函数中的静态变量"><a href="#函数中的静态变量" class="headerlink" title="函数中的静态变量"></a>函数中的静态变量</h3><p>当变量声明为static时，空间<strong>将在程序的生命周期内分配</strong>。即使多次调用该函数，静态变量的空间也<strong>只分配一次</strong>，前一次调用中的变量值通过下一次函数调用传递。这对于在C / C ++或需要存储先前函数状态的任何其他应用程序非常有用。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">demo</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> count = <span class="number">0</span>; </span><br><span class="line">    cout &lt;&lt; count &lt;&lt; <span class="string">&quot; &quot;</span>; </span><br><span class="line">    count++; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">5</span>; i++)  </span><br><span class="line">        <span class="built_in">demo</span>(); </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// output</span></span><br><span class="line"><span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> </span><br></pre></td></tr></table></figure><h3 id="类中的静态变量"><a href="#类中的静态变量" class="headerlink" title="类中的静态变量"></a>类中的静态变量</h3><p>类中的静态变量<strong>由对象共享</strong>。对于不同的对象，不能有相同静态变量的多个副本。也是因为这个原因，静态变量不能使用构造函数初始化。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Apple</span> </span></span><br><span class="line"><span class="class">&#123;</span> </span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> i; </span><br><span class="line"></span><br><span class="line">    <span class="built_in">Apple</span>() </span><br><span class="line">    &#123; </span><br><span class="line">        <span class="comment">// Do nothing </span></span><br><span class="line">    &#125;; </span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> Apple::i = <span class="number">1</span>; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    Apple obj; </span><br><span class="line">    <span class="comment">// prints value of i </span></span><br><span class="line">    cout &lt;&lt; obj.i; </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// output</span></span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure><h3 id="类中的静态函数"><a href="#类中的静态函数" class="headerlink" title="类中的静态函数"></a>类中的静态函数</h3><p>静态成员函数也不依赖于类的对象</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Apple</span> </span></span><br><span class="line"><span class="class">&#123;</span> </span><br><span class="line">    <span class="keyword">public</span>: </span><br><span class="line">        <span class="comment">// static member function </span></span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printMsg</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;Welcome to Apple!&quot;</span>; </span><br><span class="line">        &#125;</span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line"><span class="comment">// main function </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="comment">// invoking a static member function </span></span><br><span class="line">    Apple::<span class="built_in">printMsg</span>(); </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://pbs.twimg.com/media/EYyrqtIWoAAjgNv.jpg&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    
    <category term="cpp" scheme="http://example.com/tags/cpp/"/>
    
  </entry>
  
  <entry>
    <title>const</title>
    <link href="http://example.com/2022/01/16/const/"/>
    <id>http://example.com/2022/01/16/const/</id>
    <published>2022-01-15T16:00:00.000Z</published>
    <updated>2022-01-18T10:28:15.349Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://pbs.twimg.com/media/DVN7nK3X4AA204_?format=jpg&name=large"></p><span id="more"></span><h1 id="const"><a href="#const" class="headerlink" title="const"></a>const</h1><h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><ul><li><p>类型检查，<code>#define</code>只是简单的字符串替换</p></li><li><p>定义常量，防止修改</p></li><li><p><code>const</code>定义常量从汇编的角度来看，只是给出了对应的内存地址，而不是像<code>#define</code>一样给出的是立即数，所以，<code>const</code>定义的常量在程序运行过程中只有一份拷贝，而<code>#define</code>定义的常量在内存中有若干个拷贝，from <a href="https://blog.csdn.net/Eric_Jo/article/details/4138548">关于C++ const 的全面总结_亿言-CSDN博客_const</a></p></li><li><p>编译器通常不为普通const常量分配存储空间，而是将它们保存在符号表中，这使得它成为一个编译期间的常量，没有了存储与读内存的操作，使得它的效率也很高</p></li></ul><h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><h3 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h3><p>const变量默认为局部变量，如果想在其他文件访问需要前面加extern</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">const</span> <span class="keyword">int</span> ext;</span><br></pre></td></tr></table></figure><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> b = <span class="number">10</span>;</span><br><span class="line">b = <span class="number">0</span>; <span class="comment">// error: assignment of read-only variable ‘b’</span></span><br><span class="line"><span class="keyword">const</span> string s = <span class="string">&quot;helloworld&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> i,j=<span class="number">0</span> <span class="comment">// error: uninitialized const ‘i’</span></span><br></pre></td></tr></table></figure><h3 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h3><ul><li><p>如果<code>const</code>位于<code>*</code>的左侧，则<code>const</code>就是用来修饰指针所指向的变量，即指针指向为常量</p></li><li><p>如果<code>const</code>位于<code>*</code>的右侧，<code>const</code>就是修饰指针本身，即指针本身是常量。</p></li></ul><ol><li>指向常量的指针</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> * a; <span class="comment">//指向const对象的指针或者说指向常量的指针。</span></span><br><span class="line"><span class="keyword">char</span> <span class="keyword">const</span> * a; <span class="comment">//同上</span></span><br><span class="line"><span class="keyword">char</span>* a = <span class="string">&quot;abc&quot;</span>; <span class="comment">//error</span></span><br></pre></td></tr></table></figure><p><strong>允许把非const对象的地址赋给指向const对象的指针</strong>。只不过无法通过这个指针修改基础对象，但可以通过其他方法修改</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> *ptr;</span><br><span class="line"><span class="keyword">int</span> val = <span class="number">3</span>;</span><br><span class="line">ptr = &amp;val; <span class="comment">//ok</span></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> * <span class="keyword">const</span> a; <span class="comment">//指向类型对象的const指针。或者说常指针、const指针。</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> * <span class="keyword">const</span> a; <span class="comment">//指向const对象的const指针。</span></span><br></pre></td></tr></table></figure><ol start="2"><li>常指针</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> * <span class="keyword">const</span> ptr = &amp;num; <span class="comment">//指向类型对象的const指针。或者说常指针、const指针。const指针必须初始化！且const指针的值不能修改</span></span><br></pre></td></tr></table></figure><p>要指向一个变量而不是一个常量</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> num=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> * <span class="keyword">const</span> ptr=&amp;num; <span class="comment">//error! const int* -&gt; int*</span></span><br></pre></td></tr></table></figure><p>指向常量的常指针</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> p = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> * <span class="keyword">const</span> ptr = &amp;p; </span><br></pre></td></tr></table></figure><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><ul><li><p>对于非内部数据类型的输入参数，应该将值传递的方式改为<code>const </code>引用传递，目的是提高效率。</p></li><li><p>对于内部数据类型的输入参数，不存在构造、析构的过程，而复制也非常快，“值传递”和“引用传递”的效率几乎相当。不要将值传递的方式改为<code>const</code> 引用传递，否则既达不到提高效率的目的，又降低了函数的可理解性。</p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(A a)</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">const</span> A &amp;a)</span> <span class="comment">//good</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;x)</span> <span class="comment">//bad</span></span></span><br></pre></td></tr></table></figure><h3 id="类"><a href="#类" class="headerlink" title="类"></a>类</h3><ul><li><p>任何不会修改数据成员的函数都应该声明为<code>const</code>类型。</p></li><li><p>使用<code>const</code>关键字进行说明的成员函数，称为常成员函数。<strong>只有常成员函数才有资格操作常量或常对象</strong>，没有使用<code>const</code>关键字声明的成员函数不能用来操作常对象。</p></li><li><p>对于类中的const成员变量必须通过初始化列表进行初始化</p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Apple</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> people[<span class="number">100</span>];</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Apple</span>(<span class="keyword">int</span> i); </span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> apple_number;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Apple::<span class="built_in">Apple</span>(<span class="keyword">int</span> i):<span class="built_in">apple_number</span>(i)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>const对象只能访问const成员函数,而非const对象可以访问任意的成员函数,包括const成员函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//apple.cpp</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Apple</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> people[<span class="number">100</span>];</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Apple</span>(<span class="keyword">int</span> i); </span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> apple_number;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">take</span><span class="params">(<span class="keyword">int</span> num)</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> num)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> num)</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getCount</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//main.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&quot;apple.cpp&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">Apple::<span class="built_in">Apple</span>(<span class="keyword">int</span> i):<span class="built_in">apple_number</span>(i)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Apple::add</span><span class="params">(<span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line">    <span class="built_in">take</span>(num);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Apple::add</span><span class="params">(<span class="keyword">int</span> num)</span> <span class="keyword">const</span></span>&#123;</span><br><span class="line">    <span class="built_in">take</span>(num);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Apple::take</span><span class="params">(<span class="keyword">int</span> num)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;take func &quot;</span>&lt;&lt;num&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Apple::getCount</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">take</span>(<span class="number">1</span>);</span><br><span class="line"><span class="comment">//    add(); //error add方法并非const修饰，所以运行报错</span></span><br><span class="line">    <span class="keyword">return</span> apple_number;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">Apple <span class="title">a</span><span class="params">(<span class="number">2</span>)</span></span>;</span><br><span class="line">    cout&lt;&lt;a.<span class="built_in">getCount</span>()&lt;&lt;endl;</span><br><span class="line">    a.<span class="built_in">add</span>(<span class="number">10</span>);</span><br><span class="line">    <span class="function"><span class="keyword">const</span> Apple <span class="title">b</span><span class="params">(<span class="number">3</span>)</span></span>;</span><br><span class="line">    b.<span class="built_in">add</span>(<span class="number">100</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//编译： g++ -o main main.cpp apple.cpp</span></span><br><span class="line"><span class="comment">//结果</span></span><br><span class="line">take func <span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line">take func <span class="number">10</span></span><br><span class="line">take func <span class="number">100</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://pbs.twimg.com/media/DVN7nK3X4AA204_?format=jpg&amp;name=large&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    
    <category term="cpp" scheme="http://example.com/tags/cpp/"/>
    
  </entry>
  
  <entry>
    <title>unordered_map</title>
    <link href="http://example.com/2021/10/12/unorderd_map/"/>
    <id>http://example.com/2021/10/12/unorderd_map/</id>
    <published>2021-10-11T16:00:00.000Z</published>
    <updated>2021-10-12T13:20:14.459Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.redd.it/qkpninkp1d411.png"></p><span id="more"></span><h1 id="unordered-map-C-11"><a href="#unordered-map-C-11" class="headerlink" title="unordered_map(C++11)"></a>unordered_map(C++11)</h1><h2 id="头文件"><a href="#头文件" class="headerlink" title="头文件"></a>头文件</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br></pre></td></tr></table></figure><h2 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h2><table><thead><tr><th align="right">empty (1)</th><th><code>explicit unordered_map ( size_type n = /* see below */,                         const hasher&amp; hf = hasher(),                         const key_equal&amp; eql = key_equal(),                         const allocator_type&amp; alloc = allocator_type() ); explicit unordered_map ( const allocator_type&amp; alloc ); </code></th></tr></thead><tbody><tr><td align="right">range (2)</td><td><code>template &lt;class InputIterator&gt;  unordered_map ( InputIterator first, InputIterator last,                  size_type n = /* see below */,                  const hasher&amp; hf = hasher(),                  const key_equal&amp; eql = key_equal(),                  const allocator_type&amp; alloc = allocator_type() ); </code></td></tr><tr><td align="right">copy (3)</td><td><code>unordered_map ( const unordered_map&amp; ump ); unordered_map ( const unordered_map&amp; ump, const allocator_type&amp; alloc ); </code></td></tr><tr><td align="right">move (4)</td><td><code>unordered_map ( unordered_map&amp;&amp; ump ); unordered_map ( unordered_map&amp;&amp; ump, const allocator_type&amp; alloc ); </code></td></tr><tr><td align="right">initializer list (5)</td><td><code>unordered_map ( initializer_list&lt;value_type&gt; il,                size_type n = /* see below */,                const hasher&amp; hf = hasher(),                const key_equal&amp; eql = key_equal(),                const allocator_type&amp; alloc = allocator_type() );</code></td></tr></tbody></table><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">unordered_map&lt;string,<span class="keyword">int</span>&gt; student = &#123;</span><br><span class="line">        &#123;<span class="string">&quot;Sherlock&quot;</span>,<span class="number">1001</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;Batman&quot;</span>,<span class="number">1002</span>&#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">// constructing unordered_maps</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;unordered_map&gt;</span><br><span class="line"></span><br><span class="line">typedef std::unordered_map&lt;std::string,std::string&gt; stringmap;</span><br><span class="line"></span><br><span class="line">stringmap merge (stringmap a,stringmap b) &#123;</span><br><span class="line">  stringmap temp(a); temp.insert(b.begin(),b.end()); return temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main ()</span><br><span class="line">&#123;</span><br><span class="line">  stringmap first;                              // empty</span><br><span class="line">  stringmap second ( &#123;&#123;&quot;apple&quot;,&quot;red&quot;&#125;,&#123;&quot;lemon&quot;,&quot;yellow&quot;&#125;&#125; );       // init list</span><br><span class="line">  stringmap third ( &#123;&#123;&quot;orange&quot;,&quot;orange&quot;&#125;,&#123;&quot;strawberry&quot;,&quot;red&quot;&#125;&#125; );  // init list</span><br><span class="line">  stringmap fourth (second);                    // copy</span><br><span class="line">  stringmap fifth (merge(third,fourth));        // move</span><br><span class="line">  stringmap sixth (fifth.begin(),fifth.end());  // range</span><br><span class="line"></span><br><span class="line">  std::cout &lt;&lt; &quot;sixth contains:&quot;;</span><br><span class="line">  for (auto&amp; x: sixth) std::cout &lt;&lt; &quot; &quot; &lt;&lt; x.first &lt;&lt; &quot;:&quot; &lt;&lt; x.second;</span><br><span class="line">  std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id=""><a href="#" class="headerlink" title=""></a></h2>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://i.redd.it/qkpninkp1d411.png&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    
    <category term="cpp" scheme="http://example.com/tags/cpp/"/>
    
    <category term="STL" scheme="http://example.com/tags/STL/"/>
    
  </entry>
  
</feed>
